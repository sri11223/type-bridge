/**
 * Integration Tests
 * 
 * End-to-end tests for the complete type generation flow
 */

const fs = require('fs-extra');
const path = require('path');
const { generateTypes, detectORM } = require('../core/generator');

describe('Integration Tests', () => {
  const testDir = path.join(__dirname, 'integration-test');
  const outputDir = path.join(testDir, 'types');

  beforeEach(async () => {
    await fs.ensureDir(testDir);
    await fs.ensureDir(outputDir);
  });

  afterEach(async () => {
    await fs.remove(testDir);
  });

  describe('Prisma End-to-End', () => {
    const schemaPath = path.join(testDir, 'schema.prisma');

    beforeEach(async () => {
      const schema = `
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  age       Int?
  role      Role     @default(USER)
  posts     Post[]
  createdAt DateTime @default(now())
}

model Post {
  id        String   @id
  title     String
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  String
}

enum Role {
  USER
  ADMIN
}
`;
      await fs.writeFile(schemaPath, schema);
    });

    test('should detect Prisma ORM', async () => {
      // Create package.json with Prisma
      await fs.writeJson(path.join(testDir, 'package.json'), {
        dependencies: {
          '@prisma/client': '^5.0.0'
        }
      });

      const orm = await detectORM(testDir);
      expect(orm).toBe('prisma');
    });

    test('should generate types from Prisma schema', async () => {
      const config = {
        projectRoot: testDir,
        outputPath: path.join(outputDir, 'index.ts'),
        outputMode: 'single',
        schemaPath
      };

      const result = await generateTypes(config);

      expect(result.success).toBe(true);
      expect(result.modelsCount).toBe(2);
      expect(result.models).toContain('User');
      expect(result.models).toContain('Post');
    });

    test('should write generated types to file', async () => {
      const outputPath = path.join(outputDir, 'index.ts');
      const config = {
        projectRoot: testDir,
        outputPath,
        schemaPath
      };

      await generateTypes(config);

      const exists = await fs.pathExists(outputPath);
      expect(exists).toBe(true);

      const content = await fs.readFile(outputPath, 'utf-8');
      expect(content).toContain('export interface User');
      expect(content).toContain('export interface Post');
    });

    test('should handle field types correctly', async () => {
      const outputPath = path.join(outputDir, 'index.ts');
      const config = {
        projectRoot: testDir,
        outputPath,
        schemaPath
      };

      await generateTypes(config);

      const content = await fs.readFile(outputPath, 'utf-8');
      
      // Check type mappings
      expect(content).toContain('email: string');
      expect(content).toContain('age?: number | null');
      expect(content).toContain('createdAt: Date');
      expect(content).toContain('published: boolean');
    });

    test('should handle arrays correctly', async () => {
      const outputPath = path.join(outputDir, 'index.ts');
      const config = {
        projectRoot: testDir,
        outputPath,
        schemaPath
      };

      await generateTypes(config);

      const content = await fs.readFile(outputPath, 'utf-8');
      expect(content).toMatch(/posts:\s*Post\[\]/); // Array of Post references
    });

    test('should include auto-generated header', async () => {
      const outputPath = path.join(outputDir, 'index.ts');
      const config = {
        projectRoot: testDir,
        outputPath,
        schemaPath
      };

      await generateTypes(config);

      const content = await fs.readFile(outputPath, 'utf-8');
      expect(content).toContain('AUTO-GENERATED by type-bridge');
      expect(content).toContain('Do not edit manually');
    });
  });

  describe('Error Scenarios', () => {
    test('should handle missing schema file', async () => {
      const config = {
        projectRoot: testDir,
        outputPath: path.join(outputDir, 'index.ts'),
        schemaPath: path.join(testDir, 'nonexistent.prisma')
      };

      const result = await generateTypes(config);

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });

    test('should handle no ORM detected', async () => {
      const config = {
        projectRoot: testDir,
        outputPath: path.join(outputDir, 'index.ts')
      };

      const result = await generateTypes(config);

      expect(result.success).toBe(false);
      expect(result.error).toContain('ORM');
    });

    test('should handle invalid output path', async () => {
      const schemaPath = path.join(testDir, 'schema.prisma');
      await fs.writeFile(schemaPath, 'model User { id String @id }');

      const config = {
        projectRoot: testDir,
        outputPath: null,
        schemaPath
      };

      const result = await generateTypes(config);

      expect(result.success).toBe(false);
    });
  });

  describe('Multiple Models', () => {
    test('should handle complex schema with many models', async () => {
      const schemaPath = path.join(testDir, 'schema.prisma');
      const schema = `
model User {
  id String @id
}

model Post {
  id String @id
}

model Comment {
  id String @id
}

model Category {
  id String @id
}

model Tag {
  id String @id
}
`;
      await fs.writeFile(schemaPath, schema);

      const config = {
        projectRoot: testDir,
        outputPath: path.join(outputDir, 'index.ts'),
        schemaPath
      };

      const result = await generateTypes(config);

      expect(result.success).toBe(true);
      expect(result.modelsCount).toBe(5);
    });
  });

  describe('Output Modes', () => {
    const schemaPath = path.join(testDir, 'schema.prisma');

    beforeEach(async () => {
      const schema = `
model User {
  id String @id
}

model Post {
  id String @id
}
`;
      await fs.writeFile(schemaPath, schema);
    });

    test('should generate single file with all types', async () => {
      const outputPath = path.join(outputDir, 'index.ts');
      const config = {
        projectRoot: testDir,
        outputPath,
        outputMode: 'single',
        schemaPath
      };

      await generateTypes(config);

      const exists = await fs.pathExists(outputPath);
      expect(exists).toBe(true);

      const content = await fs.readFile(outputPath, 'utf-8');
      expect(content).toContain('interface User');
      expect(content).toContain('interface Post');
    });
  });

  describe('Real-World Scenarios', () => {
    test('should handle schema with all field types', async () => {
      const schemaPath = path.join(testDir, 'schema.prisma');
      const schema = `
model Example {
  stringField  String
  intField     Int
  floatField   Float
  boolField    Boolean
  dateField    DateTime
  optionalStr  String?
  arrayField   String[]
  jsonField    Json
}
`;
      await fs.writeFile(schemaPath, schema);

      const config = {
        projectRoot: testDir,
        outputPath: path.join(outputDir, 'index.ts'),
        schemaPath
      };

      const result = await generateTypes(config);

      expect(result.success).toBe(true);

      const content = await fs.readFile(path.join(outputDir, 'index.ts'), 'utf-8');
      expect(content).toContain('stringField: string');
      expect(content).toContain('intField: number');
      expect(content).toContain('boolField: boolean');
      expect(content).toContain('dateField: Date');
      expect(content).toContain('optionalStr?: string | null');
      expect(content).toContain('arrayField: string[]');
    });

    test('should format generated code properly', async () => {
      const schemaPath = path.join(testDir, 'schema.prisma');
      // Create proper multi-line Prisma schema
      await fs.writeFile(schemaPath, `model User {
  id String @id
}`);

      const config = {
        projectRoot: testDir,
        outputPath: path.join(outputDir, 'index.ts'),
        schemaPath
      };

      await generateTypes(config);

      const content = await fs.readFile(path.join(outputDir, 'index.ts'), 'utf-8');
      
      // Check formatting
      expect(content).toMatch(/export interface User \{/);
      expect(content).toMatch(/id\??: string/); // Field should be present (primary keys might be optional)
      expect(content).toMatch(/\}/);
    });
  });
});
