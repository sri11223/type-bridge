/**
 * TypeScript Type Generator
 * 
 * Converts normalized schemas to TypeScript interface definitions.
 * Works with ALL ORMs because it uses normalized format.
 */

const prettier = require('prettier');
const { STANDARD_TYPES } = require('../core/normalizer');

/**
 * Convert standard type to TypeScript type
 * @param {Object} field - Normalized field
 * @returns {string} TypeScript type string
 */
function fieldToTypeScript(field) {
  let tsType;

  // Handle enums
  if (field.isEnum && field.enumValues) {
    tsType = field.enumValues.map(v => `'${v}'`).join(' | ');
  }
  // Handle arrays
  else if (field.isArray && field.arrayOf) {
    tsType = `${field.arrayOf}[]`;
  }
  // Handle references (foreign keys)
  else if (field.isReference && field.referenceTo) {
    // Use the referenced model type name
    tsType = field.referenceTo;
  }
  // Handle nested objects
  else if (field.type === STANDARD_TYPES.OBJECT && field.nested) {
    tsType = generateInlineInterface(field.nested);
  }
  // Standard types
  else {
    tsType = field.type;
  }

  // Add optional marker if not required
  return field.required ? tsType : `${tsType} | null`;
}

/**
 * Generate inline interface for nested objects
 * @param {Object[]} fields - Array of nested fields
 * @returns {string} Inline interface string
 */
function generateInlineInterface(fields) {
  const fieldStrings = fields.map(field => {
    const optional = field.required ? '' : '?';
    return `  ${field.name}${optional}: ${fieldToTypeScript(field)};`;
  });
  
  return `{\n${fieldStrings.join('\n')}\n}`;
}

/**
 * Generate TypeScript enum
 * @param {Object} enumDef - Enum definition {name, values, type}
 * @param {Object} options - Generation options
 * @returns {string} TypeScript enum code
 */
function generateEnum(enumDef, options = {}) {
  const {
    exportType = 'export',
    includeComments = true
  } = options;

  const lines = [];

  // Add auto-generated comment
  if (includeComments) {
    lines.push(`/** Auto-generated enum */`);
  }

  // Enum declaration
  lines.push(`${exportType} enum ${enumDef.name} {`);

  // Generate enum values
  enumDef.values.forEach((value, index) => {
    const comma = index < enumDef.values.length - 1 ? ',' : '';
    lines.push(`  ${value} = '${value}'${comma}`);
  });

  lines.push(`}`);

  return lines.join('\n');
}

/**
 * Generate TypeScript interface for a model
 * @param {Object} model - Normalized model
 * @param {Object} options - Generation options
 * @returns {string} TypeScript interface code
 */
function generateInterface(model, options = {}) {
  const {
    exportType = 'export',
    includeComments = true,
    readonly = false
  } = options;

  const lines = [];

  // Add model description if available
  if (includeComments && model.description) {
    lines.push(`/**`);
    lines.push(` * ${model.description}`);
    lines.push(` */`);
  }

  // Add auto-generated comment
  if (includeComments) {
    lines.push(`/** Auto-generated from ${model.source} schema */`);
  }

  // Interface declaration
  lines.push(`${exportType} interface ${model.modelName} {`);

  // Generate fields
  model.fields.forEach(field => {
    const optional = field.required ? '' : '?';
    const readonlyPrefix = readonly ? 'readonly ' : '';
    const tsType = fieldToTypeScript(field);
    
    // Add field comment if description exists
    if (includeComments && field.description) {
      lines.push(`  /** ${field.description} */`);
    }
    
    lines.push(`  ${readonlyPrefix}${field.name}${optional}: ${tsType};`);
  });

  lines.push(`}`);

  return lines.join('\n');
}

/**
 * Generate TypeScript for multiple models
 * @param {Object[]} models - Array of normalized models
 * @param {Object} options - Generation options
 * @returns {string} TypeScript code for all models
 */
function generateTypes(models, options = {}) {
  const interfaces = models.map(model => generateInterface(model, options));
  return interfaces.join('\n\n');
}

/**
 * Format TypeScript code with Prettier
 * @param {string} code - TypeScript code
 * @returns {Promise<string>} Formatted code
 */
async function formatCode(code) {
  try {
    return await prettier.format(code, {
      parser: 'typescript',
      semi: true,
      singleQuote: true,
      trailingComma: 'es5',
      printWidth: 80,
      tabWidth: 2
    });
  } catch (error) {
    console.warn('Failed to format code with Prettier, returning unformatted:', error.message);
    return code;
  }
}

/**
 * Generate complete TypeScript file
 * @param {Object[]} models - Array of normalized models
 * @param {Object} options - Generation options
 * @returns {Promise<string>} Complete TypeScript file content
 */
async function generateTypeScriptFile(models, options = {}) {
  const {
    includeHeader = true,
    banner = null,
    enums = []
  } = options;

  const parts = [];

  // Add header comment
  if (includeHeader) {
    parts.push(`/**`);
    parts.push(` * AUTO-GENERATED by type-bridge`);
    parts.push(` * Do not edit manually`);
    parts.push(` * Generated: ${new Date().toISOString()}`);
    parts.push(` */`);
    parts.push('');
  }

  // Add custom banner if provided
  if (banner) {
    parts.push(`/* ${banner} */`);
    parts.push('');
  }

  // Generate enums first
  if (enums && enums.length > 0) {
    const enumCode = enums.map(e => generateEnum(e, options)).join('\n\n');
    parts.push(enumCode);
    parts.push('');
  }

  // Generate all types
  const types = generateTypes(models, options);
  parts.push(types);

  // Combine and format
  const code = parts.join('\n');
  return await formatCode(code);
}

/**
 * Generate index file that exports all types
 * @param {string[]} modelNames - Array of model names
 * @returns {string} Index file content
 */
function generateIndexFile(modelNames) {
  const lines = [
    `/**`,
    ` * AUTO-GENERATED by type-bridge`,
    ` * Type exports`,
    ` */`,
    ''
  ];

  // Export all types
  modelNames.forEach(name => {
    lines.push(`export type { ${name} } from './${name}';`);
  });

  return lines.join('\n');
}

module.exports = {
  generateInterface,
  generateEnum,
  generateTypes,
  generateTypeScriptFile,
  generateIndexFile,
  formatCode,
  fieldToTypeScript
};
